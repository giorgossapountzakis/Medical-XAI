# -*- coding: utf-8 -*-
"""infection_eval.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1JwOPlkxWRa2Nj8ZseTWh6SBg4-yJG8Z1
"""

from __future__ import print_function
from __future__ import division
import numpy as np
import os
import random
import pandas as pd
import seaborn as sns
import matplotlib as mpl
import matplotlib.pyplot as plt
from sklearn.metrics import accuracy_score, f1_score, precision_score, recall_score
from sklearn.metrics import confusion_matrix
import PIL.Image
import matplotlib.cm as cm
from IPython.display import Image, display
from collections import OrderedDict
import cv2
import itertools
import matplotlib.image

import torch
import torchvision
import torch.nn as nn
import torch.optim as optim
import torch.nn.functional as F
from torchvision import datasets, transforms, models
import time
import copy
from torchvision.models import *
from collections import OrderedDict
from sklearn.metrics import confusion_matrix
from sklearn.metrics import classification_report
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score
from pytorch_grad_cam import GradCAM, HiResCAM, ScoreCAM, GradCAMPlusPlus, AblationCAM, XGradCAM, EigenCAM, FullGrad
from pytorch_grad_cam import GuidedBackpropReLUModel
from pytorch_grad_cam.utils.model_targets import ClassifierOutputTarget,RawScoresOutputTarget #an to kaleso me ari8mo eksigi gia tin katigoria ayti
from pytorch_grad_cam.utils.image import show_cam_on_image ,deprocess_image,preprocess_image
from pytorch_grad_cam.metrics.road import ROADCombined
from pytorch_grad_cam import GradCAM, HiResCAM, ScoreCAM, GradCAMPlusPlus, AblationCAM, XGradCAM, EigenCAM, FullGrad
from pytorch_grad_cam import GuidedBackpropReLUModel
from pytorch_grad_cam.utils.model_targets import ClassifierOutputTarget,RawScoresOutputTarget #an to kaleso me ari8mo eksigi gia tin katigoria ayti
from pytorch_grad_cam.utils.image import show_cam_on_image ,deprocess_image,preprocess_image
from pytorch_grad_cam.metrics.road import *
from torchvision import ops
from PIL import Image
from PIL import ImageOps
from evaluate import *
# Random seed for reproducibility
seed = 42
random.seed(seed)
os.environ['PYTHONHASHSEED'] = str(seed)
np.random.seed(seed)
torch.manual_seed(seed)

"""# dataset handling"""

labels=['COVID-19','Non-COVID','Normal']

"""# normalization"""

norm_transforms = transforms.Compose([transforms.Resize(256),
                                      transforms.CenterCrop(224),
                                      transforms.ToTensor(),
                                      #transforms.Normalize([0.5, 0.5, 0.5],[0.224, 0.224, 0.224]),
                                       ])

"""# data loading"""

my_transforms = norm_transforms
image_datasets = {x: datasets.ImageFolder('/data/data1/users/el17074/Infection Segmentation Data/'+x, transform=my_transforms) for x in ['Test']}#Masked_Small_Test
testdata_dict = {x: torch.utils.data.DataLoader(image_datasets[x], batch_size=32, shuffle=False) for x in ['Test']}
inf_image_datasets = {x: datasets.ImageFolder('/data/data1/users/el17074/Infection Segmentation Data/'+x, transform=my_transforms) for x in ['Test']}#ed_Small_Test
inf_testdata_dict = {x: torch.utils.data.DataLoader(image_datasets[x], batch_size=32, shuffle=False) for x in ['Test']}


device = torch.device("cuda:0" if torch.cuda.is_available() else "cpu")
print(device)

"""# model selection(change here for fcmiddlenumber and .fc)"""


path='/data/data1/users/el17074/mymodels/efficientnet/efficientnethyperparameters2/'
fcmiddlenumber=512		
model1= models.efficientnet_b0(weights=EfficientNet_B0_Weights.DEFAULT)
num_ftrs = model1.classifier[1].in_features
model1.classifier =  nn.Sequential(OrderedDict([('fc1', nn.Linear(num_ftrs, fcmiddlenumber)),('relu', nn.ReLU()),('dropout',nn.Dropout()),('fc2', nn.Linear(fcmiddlenumber, 3))]))
model1.load_state_dict(torch.load(path+'weights.pt'))
model1=model1.to(device)
model1.eval()
print(path)



def ioufunc(tensor1, tensor2):
    # Clone the tensors to avoid modifying the originals
    tensor1 = tensor1.clone()
    tensor2 = tensor2.clone()

    # Flatten the tensors to 1D arrays
    tensor1 = tensor1.view(-1)
    tensor2 = tensor2.view(-1)

    # Compute the intersection between tensor1 and tensor2
    intersection_ = torch.sum(torch.min(tensor1, tensor2))

    # Compute the union between tensor1 and tensor2
    union_ = torch.sum(torch.max(tensor1, tensor2))

    # Compute the IoU
    iou_ = intersection_ / union_

    return iou_.item()
#prepei apo edo kai kato na to balo se ena loop apo 0 mexri 18 oste na pianei ola ta batch toy test


'''

inputs, classes = next(iter(testdata_dict['Test']))
rawinputs=inputs
model1 = model1.to(device)
inputs=inputs.to(device)
with torch.no_grad(): 
  outputs=model1(inputs)
  _, preds = torch.max(outputs, 1)
  preds=preds.cpu().numpy()
  classes=classes.numpy()

print('did predictions')


"""# Basic GradCAM"""

print('Basic GradCAM')
start_time = time.time()
model = model1
#ALLAZO TO LAYER EDO -----------------------------------------------------------
target_layers = [model.features[-1]]
with GradCAM(model=model, target_layers=target_layers,use_cuda=True) as cam:
  input_tensor = inputs
  targets = None #xrisimopoiei ta preds oysiastika
  grayscale_cam= cam(input_tensor=input_tensor, targets=targets,aug_smooth=True,eigen_smooth=True)

inf_inputs= os.listdir('/data/data1/users/el17074/Infection Segmentation Data/Test/COVID-19/infection masks/') #na do ayto ti kanei
inf_inputs=sorted(inf_inputs)
from PIL import Image
from PIL import ImageOps
totaliou=0
count=0
fig, ax = plt.subplots(8,4, figsize=(30, 30))
x,y=0,-1
for i in range(0,32):

  im_og = transforms.ToPILImage()(inputs[i]).convert('RGB')
  im_og = np.asarray(im_og, dtype="float32" )/255
  im_gradcam = show_cam_on_image(im_og, grayscale_cam[i], use_rgb=True)
  copy=np.copy(im_gradcam)
  redimage=im_gradcam[:, :, 0]
  threshold=np.percentile(redimage,50)
  redimage[redimage < threshold] = 0
  redimage[redimage >= threshold] = 255
  redimage=np.stack((redimage,)*3, axis=-1)    
  im_mask=cv2.imread('/data/data1/users/el17074/Infection Segmentation Data/Test/COVID-19/infection masks/'+str(inf_inputs[i]))
  print(str(inf_inputs[i]))
  #im_mask=im_mask[:, :, ::-1]
  im_mask=cv2.resize(im_mask,(224,224))
  im_mask=np.array(im_mask)

  im_og = transforms.ToPILImage()(inputs[i]).convert('RGB')
  im_og=np.array(im_og)
  
  visualization=np.hstack((im_og,copy,redimage,im_mask))
  visualization=transforms.ToPILImage()(visualization)
  plt.imshow(visualization)

  #redimage_tensor = torch.from_numpy(redimage[:, :, 0])
  #im_mask_tensor = torch.from_numpy(im_mask[:, :, 0])
  #iou = ioufunc(redimage_tensor, im_mask_tensor)

  #intersection = np.sum(np.minimum(A, B))
  #union = np.sum(np.maximum(A, B))
  #iou = intersection / union
  #iou = ops.box_iou(redimage_tensor, im_mask_tensor)
  #iou = iou.numpy()[0][0]

  mean_iou = load("mean_iou")
  #redimage=redimage[:, :, 0].reshape(-1)
  #im_mask=im_mask[:, :, 0].reshape(-1)
  redimage=redimage.astype(np.uint16)
  im_mask=im_mask.astype(np.uint16)
  print(type(im_mask[0]))
  iou = mean_iou.compute(predictions=redimage,references=im_mask,num_labels=3, ignore_index=1)
  totaliou=totaliou+iou['mean_iou']
  count=count+1
  print('IOU : ', iou['mean_iou'], totaliou,count)

  if i%4==0:
      x=0
      y+=1
  ax[y,x].imshow(visualization)
  ax[y,x].set_title('IoU = '+ str(iou['mean_iou']))#iou
  x+=1
plt.savefig(path+'MEANredmasks50.png')
print(totaliou/count)
#k=open(path+'totaliou.txt','w')
#k.write(str(totaliou/count))
#k.close()



'''


def ioubatch(model, target_layers,inputs,j):
  with GradCAM(model=model, target_layers=target_layers,use_cuda=True) as cam:
    input_tensor = inputs
    targets = None #xrisimopoiei ta preds oysiastika
    grayscale_cam= cam(input_tensor=input_tensor, targets=targets,aug_smooth=True,eigen_smooth=True)
  totaliou=0
  count=0
  fig, ax = plt.subplots(8,4, figsize=(30, 30))
  x,y=0,-1

  for i in range(0,32):
    im_og = transforms.ToPILImage()(inputs[i]).convert('RGB')
    im_og = np.asarray(im_og, dtype="float32" )/255
    im_gradcam = show_cam_on_image(im_og, grayscale_cam[i], use_rgb=True)
    copy=np.copy(im_gradcam)
    redimage=im_gradcam[:, :, 0]
    print(np.amin(redimage),np.amax(redimage))
    hist, bin_edges = np.histogram(redimage, density=True)
    #print(bin_edges)
    #threshold=bin_edges[5]
    threshold=np.percentile(redimage,95) #na apofasiso pio einai to kalytero
    print(threshold)
    redimage[redimage < threshold] = 255
    redimage[redimage >= threshold] = 0
    redimage=np.stack((redimage,)*3, axis=-1)    
    im_mask=cv2.imread('/data/data1/users/el17074/Infection Segmentation Data/Test/COVID-19/infection masks/'+str(inf_inputs[i+32*j]))
    print(str(inf_inputs[i+32*j]))
    #im_mask=im_mask[:, :, ::-1]
    im_mask=cv2.resize(im_mask,(224,224))
    im_mask=np.array(im_mask)
    im_og = transforms.ToPILImage()(inputs[i]).convert('RGB')
    im_og=np.array(im_og)
    visualization=np.hstack((im_og,copy,redimage,im_mask))
    visualization=transforms.ToPILImage()(visualization)
    
    mean_iou = load("mean_iou")
    redimage=redimage.astype(np.uint16)
    im_mask=im_mask.astype(np.uint16)
    iou = mean_iou.compute(predictions=redimage,references=im_mask,num_labels=3, ignore_index=1)

    #redimage_tensor = torch.from_numpy(redimage[:, :, 0])
    #im_mask_tensor = torch.from_numpy(im_mask[:, :, 0])
    #iou = ioufunc(redimage_tensor, im_mask_tensor)
    
    totaliou=totaliou+iou['mean_iou']
    count=count+1
    if i%4==0:
      x=0
      y+=1
    ax[y,x].imshow(visualization)
    ax[y,x].set_title('IoU = '+ str(iou['mean_iou']))#iou
    x+=1
    plt.savefig(path+'MEANredmaskTEST.png')
  result=totaliou/count
  print(result)
  return result

inf_inputs= os.listdir('/data/data1/users/el17074/Infection Segmentation Data/Test/COVID-19/infection masks/') #na do ayto ti kanei
inf_inputs=sorted(inf_inputs)
model = model1
#ALLAZO TO LAYER EDO -----------------------------------------------------------
target_layers = [model.features[-1]]
totaltotaliou=0
model1 = model1.to(device)
iterator=iter(testdata_dict['Test'])
for j in range(0,18):
  print('J===================================',j)
  inputs, classes = next(iterator)
  inputs=inputs.to(device)
  totaltotaliou=totaltotaliou+ioubatch(model,target_layers,inputs,j)

k=open(path+'MEANtotaltotaliou25.txt','w')
k.write(str(totaltotaliou/18))
k.close()
